import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class APILogger {
  constructor() {
    this.logFilePath = path.join(__dirname, 'api_logs.json');
    this.apiActionsLogPath = path.join(__dirname, 'api_actions.log');
    this.initializeLogFiles();
  }

  async initializeLogFiles() {
    try {
      await fs.access(this.logFilePath);
    } catch {
      await fs.writeFile(this.logFilePath, JSON.stringify([], null, 2), 'utf8');
      console.error(`Initialized API log file at: ${this.logFilePath}`);
    }

    try {
      await fs.access(this.apiActionsLogPath);
    } catch {
      const header = `# API Actions Log
# Generated by AI Testing Agent
# Started: ${new Date().toISOString()}
${'='.repeat(80)}

`;
      await fs.writeFile(this.apiActionsLogPath, header, 'utf8');
      console.error(`Initialized API actions log at: ${this.apiActionsLogPath}`);
    }
  }

  calculateCost(model, tokens) {
    const pricing = {
      'gpt-5-nano': { input: 0.00005, output: 0.0004 },  // per 1K tokens
      'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
      'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
    };

    const modelPricing = pricing[model] || pricing['gpt-3.5-turbo'];

    return {
      input: (tokens.input / 1000) * modelPricing.input,
      output: (tokens.output / 1000) * modelPricing.output,
      total: ((tokens.input / 1000) * modelPricing.input) + ((tokens.output / 1000) * modelPricing.output),
      currency: 'USD'
    };
  }

  async logRequest(action, model, request, startTime) {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const textEntry = `
[${new Date().toISOString()}] REQUEST #${requestId}
ACTION: ${action}
MODEL: ${model}
${request.summary ? `SUMMARY: ${request.summary}` : ''}
${request.actions ? `ACTIONS: ${request.actions.length} actions` : ''}
PARAMETERS: ${JSON.stringify({ model, max_tokens: request.max_tokens, temperature: request.temperature }, null, 2)}
${'- '.repeat(40)}
`;

    await fs.appendFile(this.apiActionsLogPath, textEntry, 'utf8');
    return requestId;
  }

  async logResponse(requestId, action, model, request, response, startTime, error) {
    const duration = Date.now() - startTime;

    const estimateTokens = (text) => Math.ceil(text.length / 4);

    let tokensUsed = { input: 0, output: 0, total: 0 };
    let generatedCode = '';

    if (!error && response) {
      if (response.usage) {
        tokensUsed = {
          input: response.usage.prompt_tokens || 0,
          output: response.usage.completion_tokens || 0,
          total: response.usage.total_tokens || 0
        };
      } else {
        const promptText = JSON.stringify(request);
        const responseText = response.choices?.[0]?.message?.content || '';
        tokensUsed = {
          input: estimateTokens(promptText),
          output: estimateTokens(responseText),
          total: estimateTokens(promptText) + estimateTokens(responseText)
        };
      }

      generatedCode = response.choices?.[0]?.message?.content || '';
    }

    const cost = this.calculateCost(model, tokensUsed);

    const logEntry = {
      timestamp: new Date(),
      action,
      model,
      request: {
        summary: request.summary,
        actions: request.actions,
        parameters: {
          temperature: request.temperature,
          max_tokens: request.max_tokens
        }
      },
      response: {
        success: !error,
        tokensUsed: error ? undefined : tokensUsed,
        cost: error ? undefined : cost,
        generatedCode: error ? undefined : generatedCode.substring(0, 500) + '...',
        error: error ? error.message : undefined
      },
      duration
    };

    // Append to JSON log
    try {
      const existingLogs = JSON.parse(await fs.readFile(this.logFilePath, 'utf8'));
      existingLogs.push(logEntry);

      if (existingLogs.length > 1000) {
        existingLogs.splice(0, existingLogs.length - 1000);
      }

      await fs.writeFile(this.logFilePath, JSON.stringify(existingLogs, null, 2), 'utf8');
    } catch (err) {
      console.error('Failed to update JSON log:', err);
    }

    // Append to text log
    const textEntry = `
[${new Date().toISOString()}] RESPONSE #${requestId}
STATUS: ${error ? 'ERROR' : 'SUCCESS'}
DURATION: ${duration}ms
${!error ? `TOKENS: Input=${tokensUsed.input}, Output=${tokensUsed.output}, Total=${tokensUsed.total}` : ''}
${!error ? `COST: $${cost.total.toFixed(6)} (Input: $${cost.input.toFixed(6)}, Output: $${cost.output.toFixed(6)})` : ''}
${error ? `ERROR: ${error.message}` : ''}
${!error && generatedCode ? `CODE LENGTH: ${generatedCode.length} characters` : ''}
${'='.repeat(80)}
`;

    await fs.appendFile(this.apiActionsLogPath, textEntry, 'utf8');
  }

  async getStatistics() {
    try {
      const logs = JSON.parse(await fs.readFile(this.logFilePath, 'utf8'));

      const stats = {
        totalRequests: logs.length,
        successfulRequests: logs.filter(l => l.response.success).length,
        failedRequests: logs.filter(l => !l.response.success).length,
        totalCost: 0,
        totalTokens: 0,
        averageDuration: 0,
        modelUsage: {}
      };

      let totalDuration = 0;

      for (const log of logs) {
        if (log.response.success) {
          stats.totalCost += log.response.cost?.total || 0;
          stats.totalTokens += log.response.tokensUsed?.total || 0;
          totalDuration += log.duration;

          if (!stats.modelUsage[log.model]) {
            stats.modelUsage[log.model] = {
              count: 0,
              tokens: 0,
              cost: 0
            };
          }
          stats.modelUsage[log.model].count++;
          stats.modelUsage[log.model].tokens += log.response.tokensUsed?.total || 0;
          stats.modelUsage[log.model].cost += log.response.cost?.total || 0;
        }
      }

      stats.averageDuration = stats.successfulRequests > 0
        ? Math.round(totalDuration / stats.successfulRequests)
        : 0;

      return stats;
    } catch {
      return {
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalCost: 0,
        totalTokens: 0,
        averageDuration: 0,
        modelUsage: {}
      };
    }
  }
}

export default new APILogger();