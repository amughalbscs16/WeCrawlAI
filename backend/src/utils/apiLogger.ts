import fs from 'fs/promises';
import path from 'path';
import costTracker from './costTracker';

interface APILogEntry {
  timestamp: Date;
  action: string;
  model: string;
  request: {
    summary?: string;
    actions?: string[];
    prompt?: string;
    messages?: any[];
    parameters?: any;
  };
  response: {
    success: boolean;
    tokensUsed?: {
      input: number;
      output: number;
      total: number;
    };
    cost?: {
      input: number;
      output: number;
      total: number;
      currency: string;
    };
    generatedCode?: string;
    error?: string;
  };
  duration: number;
}

class APILogger {
  private logFilePath: string;
  private apiActionsLogPath: string;

  constructor() {
    this.logFilePath = path.join(process.cwd(), 'api_logs.json');
    this.apiActionsLogPath = path.join(process.cwd(), 'api_actions.log');
    this.initializeLogFiles();
  }

  private async initializeLogFiles(): Promise<void> {
    try {
      // Initialize JSON log file
      await fs.access(this.logFilePath);
    } catch {
      await fs.writeFile(this.logFilePath, JSON.stringify([], null, 2), 'utf8');
      console.log(`Initialized API log file at: ${this.logFilePath}`);
    }

    try {
      // Initialize text log file
      await fs.access(this.apiActionsLogPath);
    } catch {
      const header = `# API Actions Log
# Generated by AI Testing Agent
# Started: ${new Date().toISOString()}
${'='.repeat(80)}

`;
      await fs.writeFile(this.apiActionsLogPath, header, 'utf8');
      console.log(`Initialized API actions log at: ${this.apiActionsLogPath}`);
    }
  }

  /**
   * Calculate cost based on model and token usage
   */
  private calculateCost(model: string, tokens: { input: number; output: number }): any {
    const pricing: { [key: string]: { input: number; output: number } } = {
      'gpt-5-nano': { input: 0.00005, output: 0.0004 },  // per 1K tokens
      'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
      'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
    };

    const modelPricing = pricing[model] || pricing['gpt-3.5-turbo'];

    return {
      input: (tokens.input / 1000) * modelPricing.input,
      output: (tokens.output / 1000) * modelPricing.output,
      total: ((tokens.input / 1000) * modelPricing.input) + ((tokens.output / 1000) * modelPricing.output),
      currency: 'USD'
    };
  }

  /**
   * Log API request
   */
  async logRequest(
    action: string,
    model: string,
    request: any,
    startTime: number
  ): Promise<string> {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Log to text file immediately
    const textEntry = `
[${new Date().toISOString()}] REQUEST #${requestId}
ACTION: ${action}
MODEL: ${model}
${request.summary ? `SUMMARY: ${request.summary}` : ''}
${request.actions ? `ACTIONS: ${request.actions.length} actions` : ''}
PARAMETERS: ${JSON.stringify({ model, max_tokens: request.max_tokens, temperature: request.temperature }, null, 2)}
${'- '.repeat(40)}
`;

    await fs.appendFile(this.apiActionsLogPath, textEntry, 'utf8');

    return requestId;
  }

  /**
   * Log API response
   */
  async logResponse(
    requestId: string,
    action: string,
    model: string,
    request: any,
    response: any,
    startTime: number,
    error?: any
  ): Promise<void> {
    const duration = Date.now() - startTime;

    // Estimate tokens (if not provided by API)
    const estimateTokens = (text: string): number => {
      // Rough estimate: 1 token â‰ˆ 4 characters
      return Math.ceil(text.length / 4);
    };

    let tokensUsed = { input: 0, output: 0, total: 0 };
    let generatedCode = '';

    if (!error && response) {
      // Extract token usage from response if available
      if (response.usage) {
        tokensUsed = {
          input: response.usage.prompt_tokens || 0,
          output: response.usage.completion_tokens || 0,
          total: response.usage.total_tokens || 0
        };
      } else {
        // Estimate tokens
        const promptText = JSON.stringify(request);
        const responseText = response.choices?.[0]?.message?.content || '';
        tokensUsed = {
          input: estimateTokens(promptText),
          output: estimateTokens(responseText),
          total: estimateTokens(promptText) + estimateTokens(responseText)
        };
      }

      generatedCode = response.choices?.[0]?.message?.content || '';
    }

    const cost = this.calculateCost(model, tokensUsed);

    // Track cumulative costs
    if (!error && cost) {
      await costTracker.addCost(
        model,
        cost.total,
        tokensUsed.input,
        tokensUsed.output,
        action
      );
    }

    // Create log entry
    const logEntry: APILogEntry = {
      timestamp: new Date(),
      action,
      model,
      request: {
        summary: request.summary,
        actions: request.actions,
        prompt: request.prompt,
        parameters: {
          temperature: request.temperature,
          max_tokens: request.max_tokens
        }
      },
      response: {
        success: !error,
        tokensUsed: error ? undefined : tokensUsed,
        cost: error ? undefined : cost,
        generatedCode: error ? undefined : generatedCode.substring(0, 500) + '...', // Truncate for log
        error: error ? error.message : undefined
      },
      duration
    };

    // Append to JSON log
    try {
      const existingLogs = JSON.parse(await fs.readFile(this.logFilePath, 'utf8'));
      existingLogs.push(logEntry);

      // Keep only last 1000 entries
      if (existingLogs.length > 1000) {
        existingLogs.splice(0, existingLogs.length - 1000);
      }

      await fs.writeFile(this.logFilePath, JSON.stringify(existingLogs, null, 2), 'utf8');
    } catch (err) {
      console.error('Failed to update JSON log:', err);
    }

    // Append to text log
    const textEntry = `
[${new Date().toISOString()}] RESPONSE #${requestId}
STATUS: ${error ? 'ERROR' : 'SUCCESS'}
DURATION: ${duration}ms
${!error ? `TOKENS: Input=${tokensUsed.input}, Output=${tokensUsed.output}, Total=${tokensUsed.total}` : ''}
${!error ? `COST: $${cost.total.toFixed(6)} (Input: $${cost.input.toFixed(6)}, Output: $${cost.output.toFixed(6)})` : ''}
${error ? `ERROR: ${error.message}` : ''}
${!error && generatedCode ? `CODE LENGTH: ${generatedCode.length} characters` : ''}
${'='.repeat(80)}
`;

    await fs.appendFile(this.apiActionsLogPath, textEntry, 'utf8');
  }

  /**
   * Get API usage statistics
   */
  async getStatistics(): Promise<any> {
    try {
      const logs = JSON.parse(await fs.readFile(this.logFilePath, 'utf8'));

      const stats = {
        totalRequests: logs.length,
        successfulRequests: logs.filter((l: APILogEntry) => l.response.success).length,
        failedRequests: logs.filter((l: APILogEntry) => !l.response.success).length,
        totalCost: 0,
        totalTokens: 0,
        averageDuration: 0,
        modelUsage: {} as any
      };

      let totalDuration = 0;

      for (const log of logs) {
        if (log.response.success) {
          stats.totalCost += log.response.cost?.total || 0;
          stats.totalTokens += log.response.tokensUsed?.total || 0;
          totalDuration += log.duration;

          // Track model usage
          if (!stats.modelUsage[log.model]) {
            stats.modelUsage[log.model] = {
              count: 0,
              tokens: 0,
              cost: 0
            };
          }
          stats.modelUsage[log.model].count++;
          stats.modelUsage[log.model].tokens += log.response.tokensUsed?.total || 0;
          stats.modelUsage[log.model].cost += log.response.cost?.total || 0;
        }
      }

      stats.averageDuration = stats.successfulRequests > 0
        ? Math.round(totalDuration / stats.successfulRequests)
        : 0;

      return stats;
    } catch {
      return {
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalCost: 0,
        totalTokens: 0,
        averageDuration: 0,
        modelUsage: {}
      };
    }
  }

  /**
   * Clear logs (with backup)
   */
  async clearLogs(): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

    // Backup existing logs
    try {
      const jsonBackup = path.join(process.cwd(), `api_logs_backup_${timestamp}.json`);
      const textBackup = path.join(process.cwd(), `api_actions_backup_${timestamp}.log`);

      await fs.copyFile(this.logFilePath, jsonBackup);
      await fs.copyFile(this.apiActionsLogPath, textBackup);

      console.log(`Logs backed up to: ${jsonBackup} and ${textBackup}`);
    } catch (err) {
      console.error('Failed to backup logs:', err);
    }

    // Clear logs
    await this.initializeLogFiles();
  }
}

export default new APILogger();